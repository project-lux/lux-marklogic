import { SPARQL_PREFIXES } from '../../lib/appConstants.mjs';
import {
  evalInModulesDatabase,
  getDocFromModulesDatabase,
} from '../../utils/utils.mjs';

const SPARQL_OPTIONS = [];
const nonFatalMessages = [];

const processMessage = (msg, level = 'info') => {
  if (level == 'fatal') {
    console.error(msg);
    throw new Error(msg);
  } else {
    if (level == 'info') {
      console.log(msg);
    } else {
      console.warn(msg);
    }
    nonFatalMessages.push({ msg, level });
  }
};

const uri = '/lib/dataConstants.mjs';
processMessage(`Generating data constants within ${uri}`);

function processDataConstant(dataConstants, configUri) {
  const configDoc = getConfig(configUri);
  const configPathInfo = getPathInfo(configUri);
  const response = executeQuery(configPathInfo, configDoc);

  // Add the constant(s) associated to this query's results and configuration.
  response.results.forEach((result) => {
    const nameKey = getConstantName(result, configDoc, configPathInfo);
    dataConstants[nameKey] = result[configDoc.valueKey];
  });

  return {
    duration: response.duration,
    count: response.results.length,
  };
}

function getConfig(configUri) {
  const config = getDocFromModulesDatabase(configUri);
  // Shouldn't happen given this came from cts.uriMatch() but leaving just in case.
  if (!config) {
    const msg = `Missing query configuration document: ${configUri}`;
    processMessage(msg, 'fatal');
  }
  return config.toObject();
}

function getPathInfo(uri) {
  const slashIdx = uri.lastIndexOf('/');
  const dotIdx = uri.lastIndexOf('.');
  return {
    path: uri.substring(0, slashIdx), // excludes trailing slash
    basename: uri.substring(slashIdx + 1, dotIdx), // excludes leading slash
    extension: uri.substring(dotIdx + 1), // excludes leading dot.
  };
}

// Always to return an array even if only one result is expected.
function executeQuery(configPathInfo, configDoc) {
  // Determine query type, and bail if unsupported.
  const queryType = configDoc.type || 'sparql';
  if (queryType !== 'sparql' && queryType !== 'mjs') {
    const msg = `Unsupported query type specified in ${fn.baseUri(
      configDoc
    )}: ${queryType}`;
    processMessage(msg, 'fatal');
  }

  // Determine the query's URI, and bail if it does not exist.
  const queryUri = `${configPathInfo.path}/${configPathInfo.basename}.${queryType}`;
  const baseQuery = getDocFromModulesDatabase(queryUri);
  if (!baseQuery) {
    const msg = `Query document does not exist in the modules database: ${queryUri}`;
    processMessage(msg, 'fatal');
  }

  // Execute the query.
  const start = new Date();
  const warnIfMultiple = configDoc.hasOwnProperty('warnIfMultiple') === true;
  let results = null;
  if (queryType === 'sparql') {
    let query = `${SPARQL_PREFIXES}\n${baseQuery}`;
    if (warnIfMultiple) {
      query += ' LIMIT 2';
    }
    results = sem.sparql(query, {}, SPARQL_OPTIONS).toArray();
  } else {
    // Else, we're presuming this is code that we can simply invoke, such as JavaScript.
    results = fn.head(xdmp.invoke(queryUri));
  }

  if (results.length == 0) {
    const msg = `The ${queryUri} query returned zero results.`;
    processMessage(msg, 'warn');
  } else if (warnIfMultiple && results.length > 1) {
    const msg = `The ${queryUri} query returned more than one result when one result was expected; using first result.`;
    processMessage(msg, 'warn');
    return {
      results: results.splice(0, 1),
      duration: new Date().getTime() - start.getTime(),
    };
  }
  return {
    results: results,
    duration: new Date().getTime() - start.getTime(),
  };
}

function getConstantName(result, queryConfig, queryPathInfo) {
  const nameKeyBase = queryConfig.hasOwnProperty('nameKey')
    ? result[queryConfig.nameKey]
    : get(queryConfig.name, queryPathInfo.basename);
  return (
    get(queryConfig.namePrefix) + nameKeyBase + get(queryConfig.nameSuffix)
  );
}

function constructModuleNode(constants) {
  const textNode = new NodeBuilder();
  textNode.addText(`
/*
  * THIS FILE IS GENERATED BY THE BUILD SCRIPT - DO NOT EDIT!
  *
  * Generated timestamp: ${new Date().toString()}
  */
import { InternalServerError } from '../lib/mlErrorsLib.mjs';
import { isNonEmptyArray } from '../utils/utils';

function hasIRI(name) {
  return IRIs.hasOwnProperty(name);
}

function getIRI(name) {
  if (hasIRI(name)) {
    return IRIs[name];
  }
  throw new InternalServerError(
    "An undefined IRI constant was referenced: '" + name + "'. Developer to correct the reference or ensure the constant is defined."
  );
}

function getOptionalIRIs(names) {
  const iris = [];
  if (isNonEmptyArray(names)) {
    names.forEach((name) => {
      if (hasIRI(name)) {
        iris.push(getIRI(name));
      }
    });
  }
  return iris;
}

function _getFieldRangeIndexCountKey(fieldRangeIndexName) {
  return 'count' + fieldRangeIndexName;
}

function hasFieldRangeIndexCountIRI(fieldRangeIndexName) {
  return hasIRI(_getFieldRangeIndexCountKey(fieldRangeIndexName));
}

function getFieldRangeIndexCountIRI(fieldRangeIndexName) {
  const key = _getFieldRangeIndexCountKey(fieldRangeIndexName);
  if (hasIRI(key)) {
    return IRIs[key];
  }
  throw new InternalServerError(
    "A field range index count IRI constant is not defined for the '" + fieldRangeIndexName + "' field range index. Developer to correct the reference or ensure the constant is defined."
  );
}

function _getLanguageConstantKey(languageCode) {
  return 'lang' + languageCode;
}

function hasLanguageIRI(languageCode) {
  return hasIRI(_getLanguageConstantKey(languageCode));
}

function getLanguageIRI(languageCode) {
  const key = _getLanguageConstantKey(languageCode);
  if (hasIRI(key)) {
    return IRIs[key];
  }
  throw new InternalServerError(
    "A language IRI constant is not defined for the '" + languageCode + "' language code. Developer to correct the reference or ensure the constant is defined."
  );
}

function getOptionalLanguageIRIs(names) {
  return isNonEmptyArray(names)
    ? getOptionalIRIs(
        names.map((name) => {
          return _getLanguageConstantKey(name);
        })
      )
    : [];
}

function resolveReferences(query) {
  const iriRefs = query.match(/@iri:[a-zA-Z]+/g);
  if (iriRefs) {
    for (let iriRef of iriRefs) {
      const iriName = iriRef.substring(iriRef.indexOf(':') + 1);
      query = query.replace(iriRef, \`<\${getIRI(iriName)}>\`);
    }
  }
  return query;
}

const IRIs = ${JSON.stringify(constants)};

export {
  IRIs,
  getIRI,
  getFieldRangeIndexCountIRI,
  getLanguageIRI,
  getOptionalIRIs,
  getOptionalLanguageIRIs,
  hasIRI,
  hasFieldRangeIndexCountIRI,
  hasLanguageIRI,
  resolveReferences
}
  `);
  return textNode.toNode();
}

// Get the given value if there is one, else the provided default value.
function get(value, defaultValue = '') {
  return value ? value : defaultValue;
}

function emitSummary() {
  // Metrics block
  const colLabelDuration = 'Duration';
  const colLabelConstants = 'Constants';
  const colLabelUris = 'Query URIs';
  const colWidthDuration = colLabelDuration.length;
  const colWidthConstants = colLabelConstants.length;
  const colWidthUris = colLabelUris.length;
  let summary = `${colLabelDuration} | ${colLabelConstants} | ${colLabelUris}\n`;
  summary += `${'-'.repeat(colWidthDuration)} | ${'-'.repeat(
    colWidthConstants
  )} | ${'-'.repeat(colWidthUris)}\n`;
  generatorMeta.sort((a, b) => {
    a.duration - b.duration;
  });
  let totalDuration = 0;
  let totalCount = 0;
  generatorMeta.forEach((entry) => {
    summary += `${' '.repeat(
      colWidthDuration - new String(entry.duration).length
    )}${entry.duration} | ${' '.repeat(
      colWidthConstants - new String(entry.count).length
    )}${entry.count} | ${entry.uri}\n`;
    totalDuration += entry.duration;
    totalCount += entry.count;
  });
  summary += `${'-'.repeat(colWidthDuration)} | ${'-'.repeat(
    colWidthConstants
  )} | ${'-'.repeat(colWidthUris)}\n`;
  summary += `${' '.repeat(
    colWidthDuration - new String(totalDuration).length
  )}${totalDuration} | ${' '.repeat(
    colWidthConstants - new String(totalCount).length
  )}${totalCount} | ${generatorMeta.length} queries`;

  // Messages block
  if (nonFatalMessages.length > 0) {
    summary += '\n\nMessages:\n\n';
    nonFatalMessages.forEach((item, i) => {
      if (item.level == 'info') {
        summary += `INFO: ${item.msg}`;
      } else {
        summary += `WARN: ${item.msg}`;
      }
      if (i + 1 < nonFatalMessages.length) {
        summary += '\n';
      }
    });
  }

  return summary;
}

// STEP 1: Get the URIs of the data constant configuration files
const configUris = evalInModulesDatabase(
  'cts.uriMatch("/runDuringDeployment/dataConstants/queries/*.json")'
).toArray();

// STEP 2: Populate the data constants object from query results.
let dataConstants = {};
const generatorMeta = [];
configUris.forEach((configUri) => {
  const queryMeta = processDataConstant(dataConstants, new String(configUri));
  generatorMeta.push({
    uri: configUri,
    duration: queryMeta.duration,
    count: queryMeta.count,
  });
});

// STEP 3: Add in the data pipeline-provided data constants, giving preference to the above query results.
const pipelineDataConstantsUri =
  '/runDuringDeployment/dataConstants/pipelineDataConstants.json';
const pipelineDataConstants = getDocFromModulesDatabase(
  pipelineDataConstantsUri
);
if (!pipelineDataConstants) {
  const msg = `There are no data pipeline-provided data constants to include; expected to find them at '${pipelineDataConstantsUri}' within the modules database.`;
  processMessage(msg, 'fatal');
}
const combinedDataConstants = {
  ...pipelineDataConstants.toObject(),
  ...dataConstants, // last one wins
};
// Alphabetize to help humans looking at the list.
dataConstants = {};
Object.keys(combinedDataConstants)
  .sort()
  .forEach((name) => {
    dataConstants[name] = combinedDataConstants[name];
  });

// STEP 4: Create or update the constants in the modules database.
const javascript = `
  const { uri, doc } = external;
  xdmp.documentInsert(uri, doc, {
    permissions: xdmp.documentGetPermissions(fn.subsequence(cts.uriMatch("*.mjs"), 1, 1))
  });
`;
evalInModulesDatabase(
  javascript,
  {
    uri: uri,
    doc: constructModuleNode(dataConstants),
  },
  true
);

// STEP 4: Summary
emitSummary();
