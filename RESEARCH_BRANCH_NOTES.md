Notes from when the research/back-to-amp-approach branch was created:

1. All existing and new endpoints (data services) are to pass a function to execute to `handleRequest`.
2. Most if not all endpoints are to accept a `unitName` parameter and pass on the value to `handleRequest`.  It is optional for consumers to provide and defaults to the tenant owner (e.g., `lux`).  More on this parameter later.
3. The `handleRequest` function's first duty is to create an instance of [EndpointConfig](/src/main/ml-modules/root/lib/EndpointConfig.mjs).  That class processes the endpoint's newly introduced configuration, which is defined within [endpointsConfig.mjs](/src/main/ml-modules/root/config/endpointsConfig.mjs).  If the endpoint's configuration is not defined or properly defined, the associated request is rejected.
4. If the request is configured not to run in read-only mode and the instance is running in read only mode, a `NotAcceptingWriteRequestsError` is thrown.  [tenantStatusLib.mjs](/src/main/ml-modules/root/lib/tenantStatusLib.mjs) presently hard codes that the instance is not in read only mode.
5. If the requesting user is a service account and the request is associated with the My Collections feature, an `AccessDeniedError` is thrown.
6. If the request makes it this far in `handleRequest` and the requesting user is a service account, the given function is simply executed and the function's return goes back to the endpoint.
7. Else, the `unitName` parameter kicks in.  So long as the specified unit name was in the `endpointAccessUnitNames` build property during deployment *and* has an associated endpoint consumer role, the requesting user will *gain* that endpoint's role.  Combined, the request will have access to the user's My Collections data and the data pipeline-provided documents that the service account has access to.
8. How does that work?  It relies on the `addSupportForExecutingWithServiceAccounts` Gradle task generating amps and libWrapper.mjs in support of enabling logged in users to have access to the same documents a service account has access to.  Each generated function has an amp that temporarily grants the caller the associated service account's role.  At runtime, `handleRequest` calls one of the service account-specific, generated functions.
9. [lux-backend-security-and-software.md](/docs/lux-backend-security-and-software.md) should be updated.
10. Four bogus data services were defined within [/src/main/ml-modules/root/ds/myLux/](/src/main/ml-modules/root/ds/myLux/).  They are all copies of the document endpoint but they are configured in [endpointsConfig.mjs](/src/main/ml-modules/root/config/endpointsConfig.mjs) differently.  Their names align with their configuration.  Try them out to test the above.  Examples:
    * Try to consume the myCollectionsReadExample.mjs endpoint with a service account.
    * Try to consume the misConfiguredExample.mjs endpoint.
    * Consume the myCollectionsReadExample.mjs endpoint, specifying a document that `ypm` does not have access to.  Try different unit names to confirm you only get the document when expected.
    * Try any of these endpoints with an invalid unit name, such as `ypmmmm`.
    * Try any of the other endpoints and you should receive an `InternalConfigurationError`.
11. Would be **great** to have automated unit tests for `handleRequest` and `EndpointConfig`.