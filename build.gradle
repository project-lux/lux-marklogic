import javax.net.ssl.*
import java.security.cert.X509Certificate

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath "com.marklogic:ml-gradle:${mlGradleVersion}"
    classpath "com.marklogic:marklogic-unit-test-client:${mlUnitTestVersion}"
    classpath "org.json:json:${orgJsonVersion}"
  }
}

plugins {
  id 'net.saliman.properties' version "${netSalimonPropertiesVersion}"
  id 'nu.studer.credentials' version "${nuStuderCredentialsVersion}"
}

apply plugin: "com.marklogic.ml-gradle"

repositories {
  mavenCentral()
}

configurations {
  mlcp
}

dependencies {
  mlBundle "com.marklogic:marklogic-unit-test-modules:${mlUnitTestVersion}"
  mlcp "com.marklogic:mlcp:${mlcpVersion}"
  mlcp "org.apache.commons:commons-csv:${orgApacheCommonsCsvVersion}"
  mlcp files("lib")
}
tasks.withType(JavaExec) {
    jvmArgs = ['-Xmx1g']
}

ext.sourceTemplatePath = "${project.projectDir}/src/main/templates"
ext.publicKeysPath = "${project.projectDir}/src/main/public-keys"
ext.buildAmpPath = "${project.projectDir}/build/main/ml-config/base/security/amps"
ext.buildModulesPath = "${project.projectDir}/build/main/ml-modules/root"
ext.buildExternalSecurityPath = "${project.projectDir}/build/main/ml-config/oauth/security/external-security"

ext.lineSep = System.getProperty("line.separator")

def codeVersion = project.getProperty('defaultCodeVersion') // Overridden in determineCodeVersion.

// This task is intended to execute before any that interact with MarkLogic Server.  It switches
// from the default default REST port (8003) to the app services port.  This port is used by the
// majority of the tasks, and has been proven necessary for setBanner (tenant app server may not
// exist).
// An exception is mlLoadModules: we need to switch to the tenant app server to ensure the REST
// options are added to the tenant's modules database.
task startWithAppServicesPort() {
  println ''
  println "Setting mlAppConfig's port to " + project.property("mlAppServicesPort") + " (from " + mlAppConfig.getRestPort() + ")"
  println ''
  mlAppConfig.setRestPort(project.property("mlAppServicesPort").toInteger())
}

// Change ML app config's rest port to that of the app services port.  See startWithAppServicesPort's
// comment for details.
task switchToAppServicesPort() {
  doFirst {
    println ''
    println "Changing mlAppConfig's port from " + mlAppConfig.getRestPort() + " to " + project.property("mlAppServicesPort")
    println ''
    mlAppConfig.setRestPort(project.property("mlAppServicesPort").toInteger())
  }
}

// Change ML app config's rest port to that of the tenant's app server port (one of them).  See
// startWithAppServicesPort's comment for details.
task switchToTenantPort() {
  doFirst {
    println ''
    println "Changing mlAppConfig's port from " + mlAppConfig.getRestPort() + " to " + project.property("mlRestPort")
    println ''
    mlAppConfig.setRestPort(project.property("mlRestPort").toInteger())
  }
}
mlLoadModules.dependsOn switchToTenantPort

task determineCodeVersion {
  def applyDefault = false
	def stdOut = ''
  try {
  stdOut = providers.exec {
    commandLine 'sh', './version.sh'
  }.standardOutput.asText.get().trim()
  } catch (Exception e) {
    println ''
    println 'WARNING: Unable to determine the code version via git; using default.'
    println ''
    applyDefault = true
  }

  stdOut = stdOut.toString().trim()
  if (applyDefault || stdOut == 'default') {
    println "Applying default code version of ${codeVersion}"
  } else {
    codeVersion = stdOut
    println "Applying derived code version of ${codeVersion}"
  }
}

// Prevent unit testing configuration from reaching production.
//
// More info in /docs/lux-backend-build-tool-and-tasks.md
task restrictUnitTestingDeployment {
  def isUnitTestingConfigIncluded = project.getProperty("mlConfigPaths").contains("test/ml-config")
  def environmentName = project.getProperty("environmentName").toLowerCase()
  if (isUnitTestingConfigIncluded) {
    def productionEnvironmentNames = project.getProperty("productionEnvironmentNames").toLowerCase()
    if (productionEnvironmentNames.contains(environmentName)) {
      throw new GradleException("It is unsecure to deploy unit testing configuration to a production environment, of which '${environmentName}' is considered.")
    } else {
      println ""
      println "Deployment to '${environmentName}' includes unit testing configuration."
    }
  } else {
    println ""
    println "Deployment to '${environmentName}' excludes unit testing configuration."
  }
}

// Resolve JSP style <% %> script and <%= %> expression syntax found within the specified template.
// Introduced to avoid embedding JavaScript within this file.  To continue supporting the template
// literal syntax ${ } in JavaScript, such references are temporarily escaped by this function, meaning
// one should not expect this function to resolve those references.  Use the JSP like syntax instead.
ext.applyTemplate = { sourceTemplatePath, templateBindings ->
  // Read template file into memory
  def text = file(sourceTemplatePath).text

  // Temporarily, change all dollar sign symbols as we want the template engine to ignore the likes of
  // '$1' and '${paramName}'.
  text = text.replaceAll(/\$/, 'DOLLAR_SIGN')

  // When a template variable reference immediately follows a JavaScript single line comment marker, remove the comment marker,
  // thereby allowing the template's variable value to be uncommented code.
  text = text.replaceAll(/\/\/\s*(?<templateVarRef><%[^>]*>)/, '${templateVarRef}')

  // Resolve all template variable references: <%...%>
  def engine = new groovy.text.SimpleTemplateEngine()
  text = engine.createTemplate(text).make(templateBindings).toString()

  // Change DOLLAR_SIGN back to the actual dollar sign symbol, such that JavaScript recognizes them.
  text = text.replaceAll(/DOLLAR_SIGN/, '\\$')

  return text
}

ext.writeToFile = { outputPath, content ->
  def file = new File("$outputPath")
  file.getParentFile().mkdirs() // Create parent directories if they don't exist
  file.withWriter { out ->
    out.println content
  }
}

// More info in /docs/lux-backend-build-tool-and-tasks.md
task addOAuthPublicKeys() {
  doLast {
    if (project.getProperty("mlConfigPaths").contains("oauth")) {
      def environmentName = project.getProperty("environmentName").toLowerCase()
      def publicKeysFilePath = "${publicKeysPath}/oauth-${environmentName}.xml"
      if (!file(publicKeysFilePath).exists()) {
        throw new GradleException("OAuth is enabled yet the public keys file '${publicKeysFilePath}' does not exist.")
      }

      def externalSecurityFilename = "lux-cognito-external-security.xml"
      def templateBindings = [
          oauthPublicKeys: file(publicKeysFilePath).text
      ]
      def content = applyTemplate("${sourceTemplatePath}/${externalSecurityFilename}", templateBindings)
      writeToFile("${buildExternalSecurityPath}/${externalSecurityFilename}", content)
      println "Added OAuth public keys to a copy of '${externalSecurityFilename}', within the build directory."
    } else {
      println "Skipping OAuth public keys addition as mlConfigPaths does not include 'oauth'."
    }
  }
}

// This project's implementation of its custom token feature.
//
// This task needs to run before any ML Gradle task that references ML Gradle configuration files does.  Rather than
// list all the related ML Gradle tasks, we're defining it as the first custom task and allow it to always run.
//
// More info in /docs/lux-backend-build-tool-and-tasks.md
task preprocessRuntimeConfigAndModules() {
  dependsOn 'determineCodeVersion'

  def names = []
  def texts = []
  def text

  // For each name, pull in the content of its file and remove the outer brackets.  Departed from JSON when we picked
  // up some double-quoted values that contained escaped double quotes --the escape character was being dropped.  
  // We now need to double-escape such double quotes *and* read it in as text.  We have also started to use single
  // quotes in the configuration files, but keeping this as a backup.
  //
  // Note: .push() adds the new item to the beginning of the array thus multiple .get(0) calls.
  names.push('contentDatabaseConfGenerated')
  text = file('./config/' + names.get(0) + '.json').text.trim()
  texts.push(text.substring(1, text.length() - 1))

  names.push('codeVersion')
  texts.push(codeVersion)

  println ''
  println 'Resolving custom token(s): ' + names.join(", ")
  println ''

  // Clear target directories first, as there could be obsolete files therein.
  delete './build/main'
  delete './build/test'

  // Copy src/main into build directory
  println "Copying src/main into the build directory."
  copy {
    from './src/main'
    into './build/main'
    include 'ml-config/**'
    include 'ml-modules/**'
    filter { line -> {
      for (def i = 0; i < names.size(); i++) {
        line = line.replaceAll('@@' + names[i] + '@@', texts[i])
      }
      return line
    }}
  }

  // Copy src/test into build directory
  println "Copying src/test into the build directory."
  copy {
    from './src/test'
    into './build/test'
    include 'ml-config/**'
    include 'ml-modules/**'
    filter { line -> {
      for (def i = 0; i < names.size(); i++) {
        line = line.replaceAll('@@' + names[i] + '@@', texts[i])
      }
      return line
    }}
  }
}
preprocessRuntimeConfigAndModules.finalizedBy addOAuthPublicKeys

// Code herein automatically executes.
task preprocessBuildSupportScripts() {
  // Resolve property references while copying into the build dir.
  println "Copying build support scripts into the build directory."
  copy {
    from './scripts/buildSupport'
    into './build/buildSupport'
    include '**'
    filter { line -> {
      // What's an existing/standard/better way to do this?
      for (Map.Entry<String, ?> entry : project.getProperties().entrySet()) {
        line = line.replaceAll('%%' +entry.getKey() + '%%', entry.getValue().toString())
      }
      return line
    }}
  }
}

task copyContentDatabaseConfGenerated(){
  def text = file('./config/contentDatabaseConfGenerated.json').text
  copy{
    from './src/main/templates'
    into './src/main/ml-modules/root/config'
    include 'contentDatabaseConfGenerated.mjs'
    filter{ line -> {
      return line.replaceAll("@@contentDatabaseConfGenerated@@", text)
    }}
  }

}
mlLoadModules.dependsOn copyContentDatabaseConfGenerated

// Defines amps and populates the libWrapper.mjs template.
task addSupportForExecutingWithServiceAccounts() {
  doLast {
    def timestamp = new Date().toString()

    // Generate amp configuration files, while collecting the wrapper function names.
    def tenantName = project.getProperty("mlAppName")
    def moduleFilename = "libWrapper.mjs"
    // Exclude leading underscore here; must add where needed below.
    // _execute_with* are the amp'd functions.
    // execute_with* are the exported functions.
    def functionNamePrefix = "execute_with"
    def functionNames = [];
    def count = 0
    def endpointAccessUnitNames = project.getProperty("endpointAccessUnitNames")
      .replaceAll("\\s", "")
      .tokenize(",")
    endpointAccessUnitNames.add(tenantName)
    endpointAccessUnitNames.each{ unit -> 
      count += 1

      // Javascript function and variable names cannot contain dashes, so we replace them with underscores
      def functionName = "${functionNamePrefix}_${unit}".replaceAll("-", "_")
      functionNames.push(functionName)

      // Amp configuration files.
      // 1. The modules database name provides multi-tenancy support.
      // 2. When the unit is the tenant owner, we only need one represented.
      def includeUnit = unit != tenantName
      def templateBindings = [
          roleNamePrefix: "${tenantName}${includeUnit ? "-${unit}" : ""}",
          functionName: "_${functionName}", // underscore needed
          moduleFilename: moduleFilename
      ]
      def content = applyTemplate("${sourceTemplatePath}/execute-with-service-account-amp.json", templateBindings)
      writeToFile("${buildAmpPath}/execute-with-${unit}-amp.json", content)
      println "Generated amp for the '${unit}' unit."
    }

    // Populate the wrapper function library.
    def functionLines = []
    def exportLines = ["export {"]
    functionNames.each{ functionName ->
      functionLines.push("const _${functionName} = (f) => { return xdmp.invokeFunction(f) };")
      functionLines.push("const  ${functionName} = import.meta.amp(_${functionName});")
      exportLines.push("  ${functionName},")
    }
    exportLines.push("};")

    def templateBindings = [
        timestamp: timestamp,
        functionLines: functionLines.reverse().join(lineSep),
        exportLines: exportLines.reverse().join(lineSep)
    ]
    def content = applyTemplate("${sourceTemplatePath}/${moduleFilename}", templateBindings)
    writeToFile("${buildModulesPath}/lib/${moduleFilename}", content)
    println "Generated ${moduleFilename}"
  }
}
mlDeploySecurity.dependsOn addSupportForExecutingWithServiceAccounts
mlLoadModules.dependsOn addSupportForExecutingWithServiceAccounts

// Developer convenience to copy a database, including from DEV to one's local environment.
// More info in /docs/lux-backend-build-tool-and-tasks.md.
//
// Should this task automatically clear the database first, like importDataFull does?
task copyDatabase(type: com.marklogic.gradle.task.MlcpTask) {
  //check if SSL is enabled and use the properties value
  def useSsl = true
  if (project.hasProperty("mlAppServicesSimpleSsl")) {
    useSsl = project.getProperty("mlAppServicesSimpleSsl").toBoolean();
  }

  classpath = configurations.mlcp
  command = "COPY"

  input_host = project.property("copyDatabaseInputHost")
  input_port = project.property("copyDatabaseInputPort").toInteger()
  input_username = project.property("copyDatabaseInputUsername")
  input_password = credentials.forKey('copyDatabaseInputPassword')
  input_database = project.property("copyDatabaseInputDatabase")

  output_host = project.property("copyDatabaseOutputHost")
  output_port = project.property("copyDatabaseOutputPort").toInteger()
  output_username = project.property("copyDatabaseOutputUsername")
  output_password = credentials.forKey('copyDatabaseOutputPassword')
  output_database = project.property("copyDatabaseOutputDatabase")

  copy_permissions=true
  copy_collections=true
  copy_metadata=true
  copy_properties=true
  copy_quality=true

  fastload=true
  batch_size = project.getProperties().getOrDefault("copyDatabaseBatchSize", "100").toInteger()
  thread_count = project.getProperties().getOrDefault("copyDatabaseThreadCount", "4").toInteger()

  ssl = useSsl
  args = ["-ssl_protocol", "tlsv1.2"]
}

// Import data running in full mode.
//    Database *is* cleared first.
//    MLCP *does* run in fast load mode --therefore it is *not* safe to update documents.
// More info in /docs/lux-backend-build-tool-and-tasks.md
//
// At least on Windows, this task can start to fail once the Gradle cache has enough entries
// to make the generated command too long.  Perhaps we can provide a shorter classpath.
task importDataFull(type: com.marklogic.gradle.task.MlcpTask) {
  //check if SSL is enabled and use the properties value
  def useSsl = true
  if (project.hasProperty("mlAppServicesSimpleSsl")) {
    useSsl = project.getProperty("mlAppServicesSimpleSsl").toBoolean();
  }
  
  classpath = configurations.mlcp
  command = "IMPORT"
  host = project.property("importDataHost")
  port = project.property("importDataPort").toInteger()
  username = project.property("importDataUsername")
  password = credentials.forKey('importDataPassword')
  database = project.property("tenantContentDatabase")
  modules = project.property("tenantModulesDatabase")
  fastload = true // Database cleared for full loads
  input_file_path = project.property("importDataFilePath")
  input_file_type = "delimited_json"
  input_compressed = project.property("importDataFileIsCompressed")
  input_compression_codec = "gzip"
  transform_module = "/documentTransforms.sjs"
  transform_function = "associateDocToDataSlice"
  uri_id = "id"
  ssl = useSsl
  args = ["-ssl_protocol", "tlsv1.2"]

  dependsOn {
    mlClearDatabase
  }
}

// Import data running in incremental mode:
//    Database is *not* cleared first.
//    MLCP does *not* run in fast load mode --therefore it is safe to update documents.
// More info in /docs/lux-backend-build-tool-and-tasks.md
//
// At least on Windows, this task can start to fail once the Gradle cache has enough entries
// to make the generated command too long.  Perhaps we can provide a shorter classpath.
task importDataIncremental(type: com.marklogic.gradle.task.MlcpTask) {
  //check if SSL is enabled and use the properties value
  def useSsl = true
  if (project.hasProperty("mlAppServicesSimpleSsl")) {
    useSsl = project.getProperty("mlAppServicesSimpleSsl").toBoolean();
  }

  classpath = configurations.mlcp
  command = "IMPORT"

  host = project.property("importDataHost")
  port = project.property("importDataPort").toInteger()
  username = project.property("importDataUsername")
  password = credentials.forKey('importDataPassword')
  database = project.property("tenantContentDatabase")
  modules = project.property("tenantModulesDatabase")
  fastload = false // Database not cleared for incremental loads
  input_file_path = project.property("importDataFilePath")
  input_file_type = "delimited_json"
  input_compressed = project.property("importDataFileIsCompressed")
  input_compression_codec = "gzip"
  transform_module = "/documentTransforms.sjs"
  transform_function = "associateDocToDataSlice"
  uri_id = "id"
  ssl = useSsl
  args = ["-ssl_protocol", "tlsv1.2"]
}

task ensureTenantStatusDocumentExists() {
  doFirst {
    // Only used if the tenant status document does not exist.
    def isProd = project.getProperty("environmentProd").toBoolean()
    def isReadOnly = project.getProperty("environmentReadOnly").toBoolean()

    def protocol = project.getProperty("mlAppServicesScheme") // assumption: if one is https, all are.
    def host = project.getProperty("mlHost")
    def port = project.getProperty("mlRestPort")
    def username = project.getProperty("mlUsername")
    def password = credentials.forKey('mlPassword')
    def getUrl = "${protocol}://${host}:${port}/ds/lux/tenantStatus/get.mjs"
    def postUrl = "${protocol}://${host}:${port}/ds/lux/tenantStatus/set.mjs"

    // Configure SSL settings for HTTPS
    if (protocol == "https") {
      // Create a trust-all SSL context (for development/testing)
      def trustAllCerts = [
        new X509TrustManager() {
          public X509Certificate[] getAcceptedIssuers() { return null }
          public void checkClientTrusted(X509Certificate[] certs, String authType) { }
          public void checkServerTrusted(X509Certificate[] certs, String authType) { }
        }
      ] as X509TrustManager[]

      def sslContext = SSLContext.getInstance("SSL")
      sslContext.init(null, trustAllCerts, new java.security.SecureRandom())
      HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory())
      
      // Disable hostname verification (for development/testing)
      HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
          return true
        }
      })
    }

    // Set up digest authentication
    Authenticator.setDefault(new Authenticator() {
      @Override
      protected PasswordAuthentication getPasswordAuthentication() {
        return new PasswordAuthentication(username, password.toCharArray())
      }
    })

    try {
      // See if the tenant status document exists.
      def getConnection = new URL(getUrl).openConnection()
      getConnection.setRequestMethod("GET")
      def responseCode = getConnection.getResponseCode()

      if (responseCode >= 200 && responseCode < 300) {
        println "Tenant status document was found; no action taken."
      } else {
        println "The tenant status document was not found; creating..."
        
        def postConnection = new URL(postUrl).openConnection()
        postConnection.setRequestMethod("POST")
        postConnection.setDoOutput(true)
        postConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded")

        def formData = "prod=${isProd}&readOnly=${isReadOnly}"

        // Send the request
        def outputStream = postConnection.getOutputStream()
        outputStream.write(formData.getBytes("UTF-8"))
        outputStream.close()
        
        def postResponseCode = postConnection.getResponseCode()
        println "POST response code: ${postResponseCode}"
        
        if (postResponseCode >= 200 && postResponseCode < 300) {
          println "Tenant status document created successfully"
        } else {
          println "Failed to create tenant status document"
          def errorStream = postConnection.getErrorStream()
          if (errorStream) {
            println "Error: ${errorStream.text}"
          }
          throw new GradleException("Failed to create tenant status document with response code ${postResponseCode} and message: ${postConnection.getResponseMessage()}")
        }
      }
      
    } catch (Exception e) {
      println "Error occurred: ${e.message}"
      throw e
    } finally {
      // Clean up the authenticator
      Authenticator.setDefault(null)
    }
  }
}
mlDeploy.finalizedBy ensureTenantStatusDocumentExists
mlLoadModules.finalizedBy ensureTenantStatusDocumentExists
copyDatabase.finalizedBy ensureTenantStatusDocumentExists

// Runs the remaining search terms generator
// More info in /docs/lux-backend-build-tool-and-tasks.md
task generateRemainingSearchTerms (type: com.marklogic.gradle.task.MarkLogicTask) {
  doFirst {
    println ""
    println "Generating the remaining search terms..."
    println ""

    def client = mlAppConfig.newDatabaseClient()
    def script = new File('./build/buildSupport/generateRemainingSearchTerms.sjs').getText('UTF-8')
    def result = client.newServerEval().javascript(script).evalAs(String.class)

    println ""
    println result
    println ""
  }
}
mlDeploy.finalizedBy generateRemainingSearchTerms
mlLoadModules.finalizedBy generateRemainingSearchTerms
copyDatabase.finalizedBy generateRemainingSearchTerms

// Runs the related lists configuration generator
// More info in /docs/lux-backend-build-tool-and-tasks.md
task generateRelatedListsConfig (type: com.marklogic.gradle.task.MarkLogicTask) {
  doFirst {
    println ""
    println "Generating the related lists configuration..."
    println ""

    def client = mlAppConfig.newDatabaseClient()
    def script = new File('./build/buildSupport/generateRelatedListsConfig.sjs').getText('UTF-8')
    def result = client.newServerEval().javascript(script).evalAs(String.class)

    println ""
    println result
    println ""
  }
}
generateRemainingSearchTerms.finalizedBy generateRelatedListsConfig

// Runs the advanced search configuration generator
// More info in /docs/lux-backend-build-tool-and-tasks.md
task generateAdvancedSearchConfig (type: com.marklogic.gradle.task.MarkLogicTask) {
  doFirst {
    println ""
    println "Generating the advanced search configuration..."
    println ""

    def client = mlAppConfig.newDatabaseClient()
    def script = new File('./build/buildSupport/generateAdvancedSearchConfig.sjs').getText('UTF-8')
    def result = client.newServerEval().javascript(script).evalAs(String.class)

    println ""
    println result
    println ""
  }
}
generateRelatedListsConfig.finalizedBy generateAdvancedSearchConfig

// Admin required to run this; thus piggybacking mlDeploySecurity.
// More info in /docs/lux-backend-build-tool-and-tasks.md
task setBanner(type: com.marklogic.gradle.task.ServerEvalTask) {
  javascript = new File('./build/buildSupport/setBanner.sjs').getText('UTF-8')
}
mlDeploySecurity.finalizedBy setBanner

task showAppServerCiphers(type: com.marklogic.gradle.task.ServerEvalTask) {
  xquery = new File('./build/buildSupport/showAppServerCiphers.xqy').getText('UTF-8')
}

//TODO: remove <show/disable>DeprecatedSSLProtocols tasks and scripts after LUX no longer uses ML 11
task showDeprecatedSSLProtocols(type: com.marklogic.gradle.task.ServerEvalTask) {
  javascript = new File('./build/buildSupport/showDeprecatedSSLProtocols.sjs').getText('UTF-8')
}

task disableDeprecatedSSLProtocols(type: com.marklogic.gradle.task.ServerEvalTask) {
  javascript = new File('./build/buildSupport/disableDeprecatedSSLProtocols.sjs').getText('UTF-8')
}
mlDeployServers.finalizedBy disableDeprecatedSSLProtocols

task getSslMinAllowTls(type: com.marklogic.gradle.task.ServerEvalTask) {
  javascript = new File('./build/buildSupport/getSslMinAllowTls.sjs').getText('UTF-8')
}

task setSslMinAllowTls(type: com.marklogic.gradle.task.ServerEvalTask) {
  javascript = new File('./build/buildSupport/setSslMinAllowTls.sjs').getText('UTF-8')
}
mlDeployServers.finalizedBy setSslMinAllowTls

task updateSSLCiphers(type: com.marklogic.gradle.task.ServerEvalTask) {
  xquery = new File('./build/buildSupport/updateSSLCiphers.xqy').getText('UTF-8')
}
mlDeployServers.finalizedBy updateSSLCiphers

// This is a convenience task intended for one with the tenant's deployer role to deploy most of the backend.
// Purposely excluded:
//
//    mlDeploySecurity: insufficient permissions
//    mlLoadData: takes a while and not always needed
//    mlReloadModules: too likely to take the modules database offline; do it manually before this task.
//
task performBaseDeployment() {
  doFirst {
    println ""
    println "Starting Base Deployment"
    println ""
  }
  dependsOn mlDeployGroups, mlDeployDatabases, mlDeployRestApis, mlDeployServers, mlLoadSchemas, mlLoadModules
  doLast {
    println ""
    println "Base Deployment Done"
    println ""
  }
}
// It was a little tricky binding mlDeployForestReplicas to performBaseDeployment; adding it above
// could result in an error if the tenant's modules database didn't exist in time.
performBaseDeployment.finalizedBy mlDeployForestReplicas

// Enables SSL on the builtin servers
// And create the certificate intended for the non-builtin servers
task enableSSL(type: com.marklogic.gradle.task.MarkLogicTask) {
  doFirst {
    def manageConfig = getProject().property("mlManageConfig")
    manageConfig.setScheme("http")
    manageConfig.setConfigureSimpleSsl(false)
    //manageConfig.setAdminScheme("http")
    //manageConfig.setAdminConfigureSimpleSsl(false)

    def adminConfig = getProject().property("mlAdminConfig")
    adminConfig.setScheme("http")
    adminConfig.setConfigureSimpleSsl(false)

    def manageClient = new com.marklogic.mgmt.ManageClient(manageConfig)
    def adminManager = new com.marklogic.mgmt.admin.AdminManager(adminConfig)

    def certManager = new com.marklogic.mgmt.resource.security.CertificateTemplateManager(manageClient)
    certManager.save(builtInAppCert())
    certManager.save(luxAppCert())

    def gtcc = new com.marklogic.appdeployer.command.security.GenerateTemporaryCertificateCommand();
    gtcc.setTemplateIdOrName("built-in-app-cert");
    gtcc.setCommonName("localhost");
    gtcc.execute(new com.marklogic.appdeployer.command.CommandContext(getAppConfig(), manageClient, adminManager));
    gtcc.setTemplateIdOrName("lux-app-cert");
    gtcc.setCommonName("localhost");
    gtcc.execute(new com.marklogic.appdeployer.command.CommandContext(getAppConfig(), manageClient, adminManager));

    adminConfig = getProject().property("mlAdminConfig")
    adminConfig.setScheme("https")
    adminConfig.setConfigureSimpleSsl(true)
    adminManager = new com.marklogic.mgmt.admin.AdminManager(adminConfig)

    manageClient.putJson("/manage/v2/servers/Admin/properties?group-id=Default", '{"ssl-certificate-template": "built-in-app-cert"}')
    adminManager.waitForRestart()
    manageClient.putJson("/manage/v2/servers/App-Services/properties?group-id=Default", '{"ssl-certificate-template": "built-in-app-cert"}')
    adminManager.waitForRestart()
    manageClient.putJson("/manage/v2/servers/Manage/properties?group-id=Default", '{"ssl-certificate-template": "built-in-app-cert"}')
    adminManager.waitForRestart()
  }
}

// Disables SSL on the builtin servers
task disableSSL(type: com.marklogic.gradle.task.MarkLogicTask) {
  doFirst {
    def manageClient = getManageClient()
    manageClient.putJson("/manage/v2/servers/Admin/properties?group-id=Default", '{"ssl-certificate-template": ""}')
    manageClient.putJson("/manage/v2/servers/App-Services/properties?group-id=Default", '{"ssl-certificate-template": ""}')
    manageClient.putJson("/manage/v2/servers/Manage/properties?group-id=Default", '{"ssl-certificate-template": ""}')

    def adminConfig = getProject().property("mlAdminConfig")
    adminConfig.setScheme("http")
    adminConfig.setConfigureSimpleSsl(false)
    def adminManager = new com.marklogic.mgmt.admin.AdminManager(adminConfig)
    adminManager.waitForRestart()

    // def manageConfig = getProject().property("mlManageConfig")
    // manageConfig.setScheme("http")
    // manageConfig.setConfigureSimpleSsl(false)
    // def mgClient = new com.marklogic.mgmt.ManageClient(manageConfig)

    // def certManager = new com.marklogic.mgmt.resource.security.CertificateTemplateManager(mgClient)
    // certManager.delete(builtInAppCert())
    // certManager.delete(luxAppCert())
  }
}

// Returns a certificate request for use on the built-in appservers
def builtInAppCert() {
    return """
    <certificate-template-properties xmlns="http://marklogic.com/manage">
      <template-name>built-in-app-cert</template-name>
      <template-description>Built-In App Servers Certificate Template</template-description>
      <key-type>rsa</key-type>
      <key-options />
      <req>
        <version>0</version>
        <subject>
          <countryName>US</countryName>
          <stateOrProvinceName>CT</stateOrProvinceName>
          <localityName>New Haven</localityName>
          <organizationName>Yale University</organizationName>
          <organizationalUnitName>ITS</organizationalUnitName>
          <emailAddress>xinjian.guo@yale.edu</emailAddress>
        </subject>
      </req>
    </certificate-template-properties>
    """
}

// Returns a certificate request for use on the LUX appservers
def luxAppCert() {
    return """
    <certificate-template-properties xmlns="http://marklogic.com/manage">
      <template-name>lux-app-cert</template-name>
      <template-description>LUX App Servers Certificate Template</template-description>
      <key-type>rsa</key-type>
      <key-options />
      <req>
        <version>0</version>
        <subject>
          <countryName>US</countryName>
          <stateOrProvinceName>CT</stateOrProvinceName>
          <localityName>New Haven</localityName>
          <organizationName>Yale University</organizationName>
          <organizationalUnitName>ITS</organizationalUnitName>
          <emailAddress>xinjian.guo@yale.edu</emailAddress>
        </subject>
      </req>
    </certificate-template-properties>
    """
}

task printCredentials {
  doFirst {
    // Most important ones
    println "mlPassword: " + credentials.forKey('mlPassword')

    // Only required by specific, infrequently-used tasks
    println "copyDatabaseInputPassword: " + credentials.forKey('copyDatabaseInputPassword')
    println "copyDatabaseOutputPassword: " + credentials.forKey('copyDatabaseOutputPassword')
    println "importDataPassword: " + credentials.forKey('importDataPassword')
  }
}

ext {
  // Configure properties based on encrypted credentials
  mlManageConfig.password = credentials.forKey('mlPassword')
  //mlManageConfig.securityPassword = credentials.forKey('mlPassword')  only needed if setting mlSecurityUsername
  mlAdminConfig.password = credentials.forKey('mlPassword')
  mlAppConfig.restAdminPassword =  credentials.forKey('mlPassword')
  mlAppConfig.appServicesPassword = credentials.forKey('mlPassword')

  // Re-initialize the connections to the Admin and Manage servers
  mlManageClient.manageConfig = mlManageConfig
  mlAdminManager.adminConfig = mlAdminConfig
}
